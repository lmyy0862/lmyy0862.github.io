<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round &#35;538 (Div. 2)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-538-Div-2%2F</url>
    <content type="text"><![CDATA[Codeforces Round #538 (Div. 2) C C题： 题目链接: &emsp;&emsp;https://codeforces.com/contest/1114/problem/C题目大意: &emsp;&emsp;给定N, b,求 ${N!}$ 在 ${b}$ 进制下末尾有多少个0题目思路: &emsp;&emsp;本题思路从10进制类比入手会较好理解。 &emsp;&emsp;首先对于一个10进制数，末尾有多少个0，我们可以直接肉眼看出（废话），但是我们可以换个角度来理解这个结果。 &emsp;&emsp;由于${10=2*5}$所以实际上对于任意整数N(暂且不说 N!的情况)，我们可以认为N可以被若干个2和5所整除。 &emsp;&emsp;例如${N = 20, N = 2 * 2 * 5}$ 因为2出现了2次，5出现了1次，所以仅能组成1个10，那么我们可以得知末尾只能有一个0。 &emsp;&emsp;所以我们不难得出第一个结论：${N!}$在 ${b}$ 进制下末尾有多少个0，取决于${N!}$ 中存在多少个 ${b}$ 中出现最少次数的质因数， &emsp;&emsp;即: &emsp;&emsp;${b=\prod_{i=1}^m p_i^{c_i}}$ ${ans = min \{ p_i |min\{c_i | i \leq m \} , i \leq m\} }$,因此我们可以考虑打素数表，算出ans。 ​ &emsp;&emsp;第二个问题：如何计算${N !}$末尾有多少个0，我们已经算出来了ans(即最少出现次数的质因数，因此我们只要计算它的贡献为多少，就能解决这个问题。 &emsp;&emsp;举个例子：${50!}$ 在 ${10}$ 进制下，5在${5,10,15,20,25,30,35,40,45,50}$提供了一次贡献，但是因为${25,50}$本身拥有2个5，所以我们可以考虑倍增成25，再次计算贡献，即最后的出现次数应该为5与25的贡献之和。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1e6 + 7;long long prime[maxn];map&lt;long long, long long&gt; ind, cnt;long long getcnt(long long p, long long x) &#123; long long res = 0; while (x) &#123; res += x / p; x /= p; &#125; return res;&#125;int main() &#123; long long n, m; for (int i = 2; i &lt;= maxn; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= maxn / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125; cin &gt;&gt; n &gt;&gt; m; long long mm = m; for (long long i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; while (mm % prime[i] == 0) &#123; ind[prime[i]]++; mm /= prime[i]; &#125; &#125; if (mm != 1) &#123; ind[mm]++; &#125; for (long long i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; if (ind[prime[i]]) &#123; cnt[prime[i]] = getcnt(prime[i], n); &#125; &#125; if (mm != 1) &#123; cnt[mm] = getcnt(mm, n); &#125; long long ans = 1e18 + 1; for (auto i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; if (ind[prime[i]]) &#123; ans = min(ans, 1LL * cnt[prime[i]] / ind[prime[i]]); &#125; &#125; if (mm != 1) &#123; ans = min(ans, 1LL * cnt[mm] / ind[mm]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1845]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FPOJ1845%2F</url>
    <content type="text"><![CDATA[POJ1845 题目链接： &emsp;&emsp;https://vjudge.net/problem/POJ-1845 题目大意： &emsp;&emsp;给定 a, b 求 ${a^b}$ 的因数和 mod 9901 的结果 题目思路： &emsp;&emsp;了解几个数学知识。 &emsp;&emsp;整数唯一分解定理 : $ A = p_1^{k_1} * p_2^{k_2} * p_3^{k_3} \cdots p_i^{k_i}$ &emsp;($p_i$均为质数) &emsp;&emsp;对于A的所有约数之和 : &emsp;&emsp;$ S = (1 + p_1 + p_1^2 + p_1^3 + \cdots p_1^{k_1}) * (1 + p_2 + p_2^2 + p_2^3 + \cdots p_2^{k_2})\cdots(1 + p_i + p_i^2 + p_i^3 + \cdots p_i^{k_i})$ &emsp;&emsp;本题如果是用等比数列求和的公式来算最终的结果的话，需要进行逆元，而在逆元的过程中需要考虑 mod 9901 是否存在倍数的情况，所以需要进行特判。 &emsp;&emsp;由于POJ不支持bits/stdc++.h和auto，CE了好几次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int mod = 9901;const int Maxn = 2e5 + 7;int prime[Maxn];map&lt;int, int&gt; mp;long long pow_m (long long a, long long b, long long c) &#123; long long res = 1; a = a % c; while (b) &#123; if (b &amp; 1) res = (res * a) % c; a = (a * a) % c; b &gt;&gt;= 1; &#125; return res;&#125;long long inv (long long a) &#123; return pow_m(a, mod - 2, mod);&#125;void init() &#123; memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= Maxn; i++) &#123; if (!prime[i]) prime[++prime[0]] = i; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= Maxn / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main(void) &#123; long long ans = 1; long long a, b, n; init(); while (cin &gt;&gt; a &gt;&gt; b) &#123; ans = 1; if (a &lt;= 1 || b == 0) &#123; cout &lt;&lt; 1 &lt;&lt; endl; continue; &#125; mp.clear(); n = a; // cout &lt;&lt; 1 &lt;&lt; endl; for (int i = 1; prime[i] * prime[i] &lt;= n; i++) &#123; if (a == 1) break; if (a % prime[i] == 0) &#123; a /= prime[i]; mp[prime[i]]++; i--; &#125; &#125; if (a != 1) mp[a]++; // cout &lt;&lt; 1 &lt;&lt; endl; map&lt;int, int&gt; :: iterator it = mp.begin(); for (; it != mp.end(); it++) &#123; // cout &lt;&lt; i.first &lt;&lt;" " &lt;&lt; i.second &lt;&lt; endl; // cout &lt;&lt; (pow_m(i.first, b * i.second, mod) - 1) &lt;&lt; endl; if ((it -&gt; first - 1) % mod == 0) ans = (b * it-&gt;second + 1) % mod * ans % mod; else ans *= ((pow_m(it-&gt;first, b * it-&gt;second + 1, mod) + mod - 1) % mod * inv(it-&gt;first - 1)); ans %= mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;533 (Div. 2)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-533-Div-2%2F</url>
    <content type="text"><![CDATA[Codeforces Round #533 (Div. 2) C,D题 C题：正解是个dp，所以看代码吧。12345678910#include &lt;iostream&gt;using namespace std;int main(void)&#123; cout &lt;&lt; "发出了蒟蒻的声音.jpg" &lt;&lt; endl; cout &lt;&lt; "臣妾不会写啊.jpg" &lt;&lt; endl; cout &lt;&lt; "只好后面补了.jpg" &lt;&lt; endl; cout &lt;&lt; "咕咕咕咕.jpg" &lt;&lt; endl; return 0;&#125; D题 题目链接： &emsp;&emsp;http://codeforces.com/contest/1105/problem/D 题目大意： &emsp;&emsp;给一张N * M 的地图，每个人每轮有ai次扩展机会，‘.’为可扩展的地方，‘#’为墙，按序号(1 - n)依次扩展，扩展若干轮直到无法再扩展，问最后每个人扩展的数目为多少。 题目思路： &emsp;&emsp;其实这题就是简单的bfs跑一遍即可，用2个队列存储一下扩展点的顺序即可。（一个也行？大概吧。) 代码有点丑，将就着看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1007;struct node &#123; int x, y, val;&#125;;int n, m, p;int dir[4][2] = &#123;-1, 0, 1, 0, 0, -1, 0, 1&#125;;int arr[N], ans[15], vis[N][N];char srr[N][N];queue&lt;pair&lt;int, int&gt; &gt; que;queue&lt;node&gt; q;node fir[N];bool check (int x, int y) &#123; if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m || srr[x][y] == '#') return false; return true;&#125;int main(void)&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 1; i &lt;= p; i++) cin &gt;&gt; arr[i]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; srr[i][j]; memset(vis, -1, sizeof(vis)); for (int k = 1; k &lt;= p; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (srr[i][j] - '0' == k) &#123; vis[i][j] = k; que.push(make_pair(i, j)); &#125;// for (int i = 1; i &lt;= n; i++) &#123;// for (int j = 1; j &lt;= m; j++)// cout &lt;&lt; vis[i][j] &lt;&lt; " ";// cout &lt;&lt; endl;// &#125; while (!que.empty()) &#123; pair&lt;int, int&gt; pa = que.front(); que.pop(); int x = pa.first; int y = pa.second; q.push(&#123;x, y, arr[vis[x][y]]&#125;); while (!que.empty() &amp;&amp; vis[que.front().first][que.front().second] == vis[x][y]) &#123; q.push(&#123;que.front().first, que.front().second, arr[vis[x][y]]&#125;); que.pop(); &#125; while (!q.empty()) &#123; node tmp = q.front(); q.pop(); if (tmp.val &lt;= 0) continue; for (int i = 0; i &lt; 4; i++) &#123; int xx = tmp.x + dir[i][0]; int yy = tmp.y + dir[i][1]; if (check (xx, yy) &amp;&amp; vis[xx][yy] == -1) &#123; vis[xx][yy] = vis[x][y]; q.push(&#123;xx, yy, tmp.val - 1&#125;); que.push(make_pair(xx, yy)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (vis[i][j] != -1) ans[vis[i][j]]++; for (int i = 1; i &lt;= p; i++) cout &lt;&lt; ans[i] &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;531 (Div. 3)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-531-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #531 (Div. 3) D题 咕 咕咕 咕咕咕 123456789#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(void) &#123; cout &lt;&lt; "发出了鸽子的声音.jpg"; return 0;&#125; 后面补。 简单记录一下这个写得很丑陋的D题，顺便习惯下如何错误的写题解 题目链接： &emsp;&emsp;http://codeforces.com/contest/1102/problem/D 题目大意： &emsp;&emsp;给定一个长度为 n（保证 n 为 3 的倍数）的串，并且只含有0,1,2 3 种数字，让你替换某些数字，使得新得到的串的0,1,2的数量相同，要求替换次数最少，并在此要求下要求字典序最小。 题目思路： &emsp;&emsp;题目数据不算大，可以直接暴力模拟。之前比赛写的太丑陋了，看看正解怎么写的，学习下。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt[3], val[3];string s;int main(void) &#123; cin &gt;&gt; n &gt;&gt; s; m = n / 3; for (int i = 0; i &lt; n; i++) cnt[s[i] - '0']++; for (int i = 0; i &lt; 3; i++) val[i] = cnt[i]; for (int i = 0; i &lt; n; i++) &#123; val[s[i] - '0']--; if (cnt[s[i] - '0'] &gt; m) for (int j = 0; j &lt; 3; j++) if (cnt[j] &lt; m) &#123; if (j &gt; s[i] - '0' &amp;&amp; val[s[i] - '0'] &gt;= cnt[s[i] - '0'] - m) break; cnt[s[i] - '0']--; s[i] = char(j + '0'); cnt[j]++; break; &#125; &#125; cout &lt;&lt; s &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
