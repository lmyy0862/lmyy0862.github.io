<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大概就是简单二分吧？]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2F%E5%A4%A7%E6%A6%82%E5%B0%B1%E6%98%AF%E7%AE%80%E5%8D%95%E4%BA%8C%E5%88%86%E5%90%A7%2F</url>
    <content type="text"><![CDATA[大概就是简单二分吧？ 只包含了题解和解题要点 不包含题意。 题目链接：https://vjudge.net/contest/290258 &emsp;&emsp; 建议大家看完题解 及时补题。&emsp;&emsp; 建议大家看完题解 及时补题。&emsp;&emsp; 建议大家看完题解 及时补题。 A题：题解：&emsp;&emsp;数列统一减去一个枚举的区间平均值，如果能在数列中找到一个长度大于等于F且区间和大于等于0的区间，就说明枚举的平均值是答案，通过二分答案的方法找出最大的那个平均值。&emsp;&emsp;是否存在长度大于等于F且区间和大于等于0的区间方法如下：以i为右界，预处理出所有长度为F的区间和，记为sum[i]，通过下面的递推公式求出长度大于等于F的所有区间和的最大值。&emsp;&emsp;sum[i] = max(sum[i], sum[i-1]+a[i]);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int Maxn = 1e5+10;const int INF = 0x3f3f3f3f;int a[Maxn];long long sum[Maxn];bool ok(int x, int F, int n) &#123; int L = 0, R = 0, cur = F-1; long long ans; sum[cur] = 0; while(R &lt; F) sum[cur] += a[R++]-x; while(R &lt; n) &#123; sum[cur+1] = sum[cur]-a[L++]+a[R++]; cur++; &#125; ans = sum[F-1]; for(int i = F; i &lt; n; ++i) &#123; sum[i] = max(sum[i], sum[i-1]+a[i]-x); ans = max(ans, sum[i]); &#125; if(ans &gt;= 0) return true; else return false;&#125;int main(void)&#123; int N, F; scanf("%d%d", &amp;N, &amp;F); for(int i = 0; i &lt; N; ++i) &#123; scanf("%d", &amp;a[i]); a[i] *= 1000; &#125; int L = 0, R = 2000000, mid; while(L &lt; R) &#123; int mid = (L+R+1)/2; if(ok(mid, F, N)) L = mid; else R = mid-1; &#125; printf("%d\n", L); return 0; &#125; B题：题解：&emsp;&emsp;交互题和传统的题目不同，传统的题目是题目给数据，要你回答问题，而交互题则相反。这道题的意思是，你猜一个数，题目会返回3种回答，大，小，等于。cout 猜数，系统通过cin 返回回答。&emsp;&emsp;难点：通过询问n次1来确定p的序列，因为不会存在比1还小的数字，如果系统回答小于的话，那么当前的回答就是错误的，以此确定p序列。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int Maxn = 1e5+10;const int INF = 0x3f3f3f3f;bool p[60];int main(void)&#123; int n, m, ans; scanf("%d%d", &amp;n, &amp;m); memset(p, true, sizeof(p)); for(int i = 0; i &lt; m; ++i) &#123; cout &lt;&lt; 1 &lt;&lt; endl; scanf("%d", &amp;ans); if(ans == 0) return 0; if(ans == -1) p[i] = false; &#125; int L = 1, R = n, mid, cur = 0; while(1) &#123; mid = (ll)(L+R)/2; cout &lt;&lt; mid &lt;&lt; endl; scanf("%d", &amp;ans); if(ans == 0) break; if(!p[cur]) &#123; if(ans == -1) L = mid+1; else if(ans == 1) R = mid-1; &#125; else &#123; if(ans == -1) R = mid-1; else if(ans == 1) L = mid+1; &#125; cur = (cur+1)%m; &#125; return 0;&#125; C题：题解：&emsp;&emsp;二分枚举步数，判断步数是否能走到终点。风的方向是固定的，而人控制的方向是随意的，可以先把由风移动的部分走完，再走人控制的部分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int Maxn = 1e5+10;char str[Maxn];int n;bool ok(ll step, ll x1, ll y1, ll x2, ll y2) &#123; ll xx, yy; xx = yy = 0; for(int i = 0; i &lt; n; ++i) &#123; if(str[i] == 'U') yy++; else if(str[i] == 'R') xx++; else if(str[i] == 'L') xx--; else yy--; &#125; xx *= step/n; yy *= step/n; for(int i = 0; i &lt; step%n; ++i) &#123; if(str[i] == 'U') yy++; else if(str[i] == 'R') xx++; else if(str[i] == 'L') xx--; else yy--; &#125; x1 += xx; y1 += yy; ll dif = abs(x1-x2)+abs(y1-y2); if(dif &gt; step) return false; else return true;&#125;int main(void)&#123; ll x1, x2, y1, y2; scanf("%lld%lld%lld%lld%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;n); scanf("%s", str); ll L = 1, R = (abs(x1-x2)+abs(y1-y2))*n, mid; if(!ok(R, x1, y1, x2, y2)) &#123; printf("-1\n"); return 0; &#125; while (L &lt; R) &#123; mid = (L+R)/2; if(ok(mid, x1, y1, x2, y2)) R = mid; else L = mid+1; &#125; printf("%lld\n", R); return 0; &#125; D题： 题解：&emsp;&emsp;二分答案求出在规定时间内到达终点，车的油箱容量最少要多少，在所有容量大于或者等于求出的最少容量的车中选出价钱最少的车。&emsp;&emsp;每次只考虑当前位置到最近加油站要花费的最少时间，如果能到达终点，计算出总的时间是否在规定范围之内。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int Maxn = 2e5+10;const int INF = 0x3f3f3f3f;const long long LINF = 1e18;ll n, k, s, t, g[Maxn], v[Maxn], cost[Maxn];bool ok(ll x) &#123; ll time = 0, p = 0, gg = x; for(int i = 0; i &lt; k; ++i) &#123; if(g[i]-p &gt; gg || time &gt; t) return false; gg -= (g[i]-p)*2; time += g[i]-p; if(gg &lt; 0) time += (-gg); gg = x; p = g[i]; &#125; if(s-p &gt; gg) return false; gg -= (s-p)*2; time += s-p; if(gg &lt; 0) time += (-gg); if(time &gt; t) return false; return true;&#125;int main(void)&#123; scanf("%lld%lld%lld%lld", &amp;n, &amp;k, &amp;s, &amp;t); ll L = 1, R = 1, mid; for(int i = 0; i &lt; n; ++i) &#123; scanf("%lld%lld", &amp;cost[i], &amp;v[i]); R = max(R, v[i]); &#125; for(int i = 0; i &lt; k; ++i) scanf("%lld", &amp;g[i]); sort(g, g+k); ll ans = LINF; if(!ok(R)) &#123; printf("-1\n"); return 0; &#125; while (L &lt; R) &#123; mid = (L+R)/2; if(ok(mid)) R = mid; else L = mid+1; &#125; for(int i = 0; i &lt; n; ++i) &#123; if(v[i] &gt;= R) ans = min(ans, cost[i]); &#125; printf("%lld\n", ans); return 0;&#125; E题：题解：&emsp;&emsp;虽然电梯和楼梯很多，但真正需要考虑的只有4种情况，离本人两端最近的电梯和楼梯，取这4种情况的最小值就是答案，这里通过二分查找的方法能确定离本人两端最近的楼梯和电梯的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int Maxn = 1e5+10;const long long LINF = 1e18;int n, m, l, e, v, ll[Maxn], ee[Maxn]; int main(void) &#123; scanf("%d%d%d%d%d", &amp;n, &amp;m, &amp;l, &amp;e, &amp;v); for(int i = 0; i &lt; l; ++i) scanf("%d", &amp;ll[i]); for(int i = 0; i &lt; e; ++i) scanf("%d", &amp;ee[i]); sort(ll, ll+l); sort(ee, ee+e); int q, x1, x2, y1, y2; LL tmp1, tmp2; scanf("%d", &amp;q); while(q--) &#123; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); int p; tmp1 = tmp2 = LINF; if(x1 == x2) printf("%d\n", abs(y1-y2)); else &#123; if(l != 0) &#123; p = lower_bound(ll, ll+l, y1)-ll; if(p &lt; l &amp;&amp; p &gt; 0) p = abs(y1-ll[p])+abs(y2-ll[p]) &gt; abs(y1-ll[p-1])+abs(y2-ll[p-1]) ? p-1 : p; else if(p == l) p--; tmp1 = abs(y1-ll[p])+abs(y2-ll[p])+abs(x1-x2); &#125; if(e != 0) &#123; p = lower_bound(ee, ee+e, y1)-ee; if(p &lt; e &amp;&amp; p &gt; 0) p = abs(y1-ee[p])+abs(y2-ee[p]) &gt; abs(y1-ee[p-1])+abs(y2-ee[p-1]) ? p-1 : p; else if(p == e) p--; tmp2 = abs(y1-ee[p])+abs(y2-ee[p])+abs(x1-x2)/v; tmp2 = abs(x1-x2)%v == 0 ? tmp2 : tmp2+1; &#125; printf("%lld\n", min(tmp1, tmp2)); &#125; &#125; return 0; &#125; F题：题解：&emsp;&emsp;二分枚举答案，算出n*m的乘法表中，比枚举的答案小的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int Maxn = 2e5+10;const int INF = 0x3f3f3f3f;const long long LINF = 1e18; ll n, m, k; bool ok(ll x) &#123; ll sum = 0; for(int i = 1; i &lt;= n; ++i) &#123; sum += min(m, x/i); &#125; if(sum &gt;= k) return true; else return false; &#125;int main(void)&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; ll L = 0, R = n*m, mid; while (L &lt; R) &#123; mid = (L+R)/2; if(ok(mid)) R = mid; else L = mid+1; &#125; cout &lt;&lt; R &lt;&lt; endl; return 0;&#125; G题： 题解： &emsp;&emsp;二分枚举答案，判断答案可行的方法如下： 通过枚举的答案，可以算出每一个植物至少需要浇多少次水，因为机器人不能停留在一个地方浇水，所以一个植物要想被浇灌n次水，就必须在两个植物之间反复走动，最好的方法就是从第一个植物开始，在第一个和第二个植物之间跳动，不仅能浇灌第一个植物，同时还能浇灌第二个植物。 &emsp;&emsp;需要注意的有两点：1，题目给出的数据范围比较大，注意数据溢出。2，当浇灌倒数第二个植物的时候要注意的是，如果倒数第二个浇灌完，最后一个也完成需要浇灌的次数时就不用再继续往前走了，这样可以省一步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int Maxn = 1e5+10;const int INF = 0x3f3f3f3f;const long long LINF = 1e18;const double eps = 1e-6;int a[Maxn];ll d[Maxn];bool ok(ll ans, ll m, int n) &#123; for(int i = 0; i &lt;= n+1; ++i) d[i] = 0; ll tmp; for(int i = 1; i &lt;= n; ++i) &#123; d[i]++; tmp = ans/a[i]; if(ans%a[i] != 0) tmp++; if(i == n &amp;&amp; d[i]-1 &gt;= tmp) d[i]--; if(d[i] &gt;= tmp) continue; d[i+1] += tmp-d[i]; d[i] = tmp; &#125; for(int i = 1; i &lt;= n+1; ++i) &#123; m -= d[i]; if(m &lt; 0) return false; &#125; return true;&#125;int main(void)&#123; int T; scanf("%d", &amp;T); while(T--) &#123; int n; ll m; scanf("%d%lld", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); ll L = 0, R = (ll)Maxn*m, mid; while (L &lt; R) &#123; mid = (L+R+1)/2; if(ok(mid, m, n)) L = mid; else R = mid-1; &#125; printf("%lld\n", L); &#125; return 0;&#125; H题：&emsp;&emsp;待补。 I题：题解：&emsp;&emsp;每一个区间和都能用一个左界和右界确定下来，对于一个区间和x可以用l和r两个值来代替，把区间和相同的放在一个容器处理。&emsp;&emsp;因为n只有1500，用前缀和求出所有可能的区间和，区间和相同的放在用一个容器里面，在相同区间和的容器找最多有多少个左右界不相交的区间。这里只需要根据右界从小到大排好序，从左到右取不相交的个数就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int Maxn = 3e6+10;const int INF = 0x3f3f3f3f;const long long LINF = 1e18;const double eps = 1e-6;map&lt;ll, ll&gt; num;vector&lt;pii&gt; x[Maxn];ll pref[Maxn];bool cmp(pii &amp;a1, pii &amp;a2) &#123; if(a1.second == a2.second) return a1.first &lt; a2.first; else return a1.second &lt; a2.second;&#125;int main(void)&#123; int n, m = 0; scanf("%d", &amp;n); memset(pref, 0, sizeof(pref)); for(int i = 1; i &lt;= n; ++i) scanf("%lld", &amp;pref[i]); for(int i = 1; i &lt;= n; ++i) pref[i] += pref[i-1]; for(int l = 1; l &lt;= n; ++l) &#123; for(int r = l; r &lt;= n; ++r) &#123; ll tmp = pref[r]-pref[l-1]; if(num.find(tmp) == num.end()) num[tmp] = m++; &#125; &#125; for(int l = 1; l &lt;= n; ++l) &#123; for(int r = l; r &lt;= n; ++r) &#123; ll tmp = pref[r]-pref[l-1]; x[num[tmp]].push_back(make_pair(l, r)); &#125; &#125; int id, cnt = 0, last; for(int i = 0; i &lt; m; ++i) &#123; sort(x[i].begin(), x[i].end(), cmp); int tmp = 0; for(int j = 0; j &lt; x[i].size(); ++j) &#123; if(!j) &#123; tmp++; last = j; &#125; else &#123; if(x[i][j].first &gt; x[i][last].second) &#123; tmp++; last = j; &#125; &#125; &#125; if(cnt &lt; tmp) &#123; cnt = tmp; id = i; &#125; &#125; printf("%d\n", cnt); for(int i = 0; i &lt; x[id].size(); ++i) &#123; // cout &lt;&lt; x[id][i].first &lt;&lt; " " &lt;&lt; x[id][i].second &lt;&lt; endl; if(!i || x[id][i].first &gt; x[id][last].second) &#123; last = i; printf("%d %d\n", x[id][i].first, x[id][i].second); &#125; &#125; return 0;&#125; J题：题解：&emsp;&emsp;先定第一个元素为1，在不考虑数字范围的情况下(超出n或者小于1都可以)，根据q数列求出一个不重复的数列，如果得到的数列有重复就输出-1，如果不重复，我们取这个序列的最小值，加上某个值x，让这个最小值变成1，其他的数统一加x，这个时候的最大值如果不等于n输出-1，否则输出序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int Maxn = 2e5+10;const int INF = 0x3f3f3f3f;const long long LINF = 1e18;ll a[Maxn], q[Maxn];map&lt;ll, ll&gt; vis;int main(void)&#123; int n; scanf("%lld", &amp;n); for(int i = 1; i &lt; n; ++i) scanf("%lld", &amp;q[i]); ll minx = 1, maxn = 1; a[0] = 1; vis[1] = 1; for(int i = 1; i &lt; n; ++i) &#123; a[i] = a[i-1]+q[i]; if(vis[a[i]]) &#123; printf("-1\n"); return 0; &#125; vis[a[i]] = 1; minx = min(a[i], minx); maxn = max(a[i], maxn); &#125; if(maxn-minx+1 != n) printf("-1\n"); else &#123; for(int i = 0; i &lt; n; ++i) &#123; printf("%lld ", a[i]-minx+1); &#125; printf("\n"); &#125; return 0;&#125; K题： 题解： &emsp;&emsp;先离线记录从左到右的单调递增数列，记为 h[] &emsp;&emsp;下面分几种情况：&emsp;&emsp;修改的点x不在h里面：&emsp;&emsp;&emsp;&emsp;1，值减少，答案不变；&emsp;&emsp;&emsp;&emsp;2，值增加，二分h数组，答案减去点x右端比修改值小或者等于的个数。&emsp;&emsp;修改的点x在h里面：&emsp;&emsp;&emsp;&emsp;1，值减少；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(1) x的值小于或者等于左端的值，答案加上x和x右端之间的最小值大于x左端值的单调递增个数并且减去1 (减去x)&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(2) x值大于左端的值，和上面一样，只是不用减1&emsp;&emsp;&emsp;&emsp;2，值增加； 二分h数组，答案减去右端比修改值小或者等于的个数。&emsp;&emsp;ps：h数列两端的单调递增数列要另外离线求出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int Maxn = 1e5+10;const int INF = 0x3f3f3f3f;const long long LINF = 1e18;int num[Maxn], h[Maxn], a[Maxn];vector&lt;int&gt; x[Maxn];int main(void)&#123; int T, n, m; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); int cnt = 0; num[cnt] = 0; h[cnt] = a[0]; cnt++; for(int i = 1; i &lt; n; ++i) &#123; if(a[i] &gt; h[cnt-1]) &#123; num[cnt] = i; h[cnt] = a[i]; cnt++; &#125; &#125; num[cnt] = n; for(int i = 0; i &lt;= n; ++i) x[i].clear(); for(int i = 0; i &lt; cnt; ++i) &#123; int ct = 0; for(int j = num[i]+1; j &lt; num[i+1]; ++j) &#123; if(x[i].size() == 0 || x[i][ct-1] &lt; a[j]) &#123; x[i].push_back(a[j]); ct++; &#125; &#125; &#125; int p, val; while(m--) &#123; scanf("%d%d", &amp;p, &amp;val); p--; int pp = lower_bound(num, num+cnt, p)-num, ans = cnt; if(pp &lt; cnt &amp;&amp; num[pp] == p) &#123; if(h[pp] &gt; val) &#123; if(pp &gt; 0 &amp;&amp; h[pp-1] &gt;= val) ans += (x[pp].end()-upper_bound(x[pp].begin(), x[pp].end(), h[pp-1])-1); else ans += (x[pp].end()-upper_bound(x[pp].begin(), x[pp].end(), val)); &#125; else if(h[pp] &lt; val) &#123; int xx = upper_bound(h+pp+1, h+cnt, val)-h; ans -= (xx-pp-1); &#125; &#125; else &#123; if(pp &gt; 0 &amp;&amp; h[pp-1] &gt;= val); else &#123; int xx = upper_bound(h, h+cnt, val)-h; ans -= (xx-pp); ans++; &#125; &#125; printf("%d\n", ans); &#125; &#125; return 0;&#125; L题：题解：&emsp;&emsp;枚举A和B的值，C+D的值事先求出来，通过二分查找-(A+B)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int Maxn = 1e5+10;const int INF = 0x3f3f3f3f;const long long LINF = 1e18;vector &lt;int&gt; a;int b[Maxn][10], n;int main(void)&#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; 4; ++j) scanf("%d", &amp;b[i][j]); &#125; a.clear(); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; a.push_back(b[i][2]+b[j][3]); &#125; &#125; sort(a.begin(), a.end()); ll ans = 0; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; ans += (upper_bound(a.begin(), a.end(), -(b[i][0]+b[j][1]))- lower_bound(a.begin(), a.end(), -(b[i][0]+b[j][1]))); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; if(T) cout &lt;&lt; endl; &#125; return 0;&#125; M题：题解：&emsp;&emsp;题目的问题可以改成修改区间，使得机器人能到达终点，求最小的修改区间长度。我们只需要二分枚举修改的区间长度就行了。固定区间长度，x和y的值可以用前缀和求，下面的代码用的是尺取法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int Maxn = 2e5+10;const long long LINF = 1e18;char str[Maxn];int n, x, y;bool ok(LL len) &#123; LL xx = 0, yy = 0; for(int i = 0; i &lt; n; ++i) &#123; if(str[i] == 'U') yy++; else if(str[i] == 'D') yy--; else if(str[i] == 'R') xx++; else xx--; &#125; int L = 0, R = 0; while(R &lt; len) &#123; if(str[R] == 'U') yy--; else if(str[R] == 'D') yy++; else if(str[R] == 'R') xx--; else xx++; R++; &#125; LL tmp = abs(xx-x)+abs(yy-y); if(tmp &lt;= len &amp;&amp; (len-tmp)%2 == 0) return true; while(R &lt; n) &#123; if(str[R] == 'U') yy--; else if(str[R] == 'D') yy++; else if(str[R] == 'R') xx--; else if(str[R] == 'L')xx++; if(str[L] == 'U') yy++; else if(str[L] == 'D') yy--; else if(str[L] == 'R') xx++; else if(str[L] == 'L')xx--; L++; R++; tmp = abs(xx-x)+abs(yy-y); if(tmp &lt;= len &amp;&amp; (len-tmp)%2 == 0) return true; &#125; return false;&#125; int main(void) &#123; scanf("%d", &amp;n); scanf("%s", str); scanf("%d%d", &amp;x, &amp;y); LL L = 0, R = n, mid; if(!ok(R)) &#123; printf("-1\n"); return 0; &#125; while (L &lt; R) &#123; mid = (L+R)/2; if(ok(mid)) R = mid; else L = mid+1; &#125; printf("%lld\n", R); return 0; &#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始的前缀和]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C%2F</url>
    <content type="text"><![CDATA[从零开始的前缀和 只包含了题解和解题要点 不包含题意。（部分题单独写题解 附上链接） 题目链接：https://vjudge.net/contest/286126 &emsp;&emsp; 建议大家看完题解 及时补题。&emsp;&emsp; 建议大家看完题解 及时补题。&emsp;&emsp; 建议大家看完题解 及时补题。 A题：题解：&emsp;&emsp;此题为二维前缀和裸题，我们只需要将二维前缀和预处理出来，然后对于答案所求的边长进行枚举(从小到大)就可以得到一个最大的矩阵价值。&emsp;&emsp;然后我们需要注意枚举时的细节问题，为防止边长溢出（在-r时 具体见代码） 建议 i = r 开始枚举，无其他难点。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt; // 万能头文件（基本包括了能用到的所有函数） POJ不可以使用using namespace std;const int N = 5011;const int INF = 0x3f3f3f3f;int arr[N][N];int main(void)&#123; memset(arr, 0, sizeof(arr)); int n, r, maxc = -1, maxr = -1, ans = -1; cin &gt;&gt; n &gt;&gt; r; maxc = maxr = r; for (int i = 1; i &lt;= n; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; x++, y++; arr[x][y] = val; maxc = max(x, maxc); maxr = max(y, maxr); &#125; for (int i = 1; i &lt;= maxc; i++) &#123; // 二维前缀和预处理 for (int j = 1; j &lt;= maxr; j++) arr[i][j] += arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1]; &#125; for (int i = r; i &lt;= maxc; i++) // 这里为了防止溢出 所以我从r开始枚举的。 for (int j = r; j &lt;= maxr; j++) &#123; ans = max(ans, arr[i][j] + arr[i - r][j - r] - arr[i - r][j] - arr[i][j - r]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B题：题解：&emsp;&emsp;此题为差分序列的裸题，将差分序列从区间问题转化成单点处理的问题，是差分序列的基本操作。&emsp;&emsp;然后我们需要注意此题的一个比较坑的点，由于在读入时有可能对同一区间操作若干次，但是实际上我们只要一次的单点处理，所以我们需要对处理过的区间标记一下。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int INF = 0x3f3f3f3f;int arr[10007];map&lt;pair&lt;int, int&gt;, int&gt;vis; //用map来对区间进行标记 pair大家可以成一个只包含了两个int类型的结构体。int main(void) &#123; int n, pos, h, R; while(cin &gt;&gt; n &gt;&gt; pos &gt;&gt; h &gt;&gt; R) &#123; vis.clear(); memset(arr, 0, sizeof(arr)); for (int i = 1; i &lt;= R; i++) &#123; int l, r; pair&lt;int, int&gt; pa; cin &gt;&gt; l &gt;&gt; r; if (l &gt; r) swap(l, r); pa.first = l, pa.second = r; if (vis[pa]) // 如果该区间已经出现过 则跳过。 continue; vis[pa]++; arr[l + 1]--; arr[r]++; &#125; for (int i = 1; i &lt;= n; i++) arr[i] += arr[i - 1]; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; arr[i] + h &lt;&lt; endl; &#125; return 0;&#125; C题：题解：&emsp;&emsp;此题有一些难度，大家需要掌握一些前置知识。&emsp;&emsp;前置知识：&emsp;&emsp;&emsp;&emsp;1：二分答案&emsp;&emsp;&emsp;&emsp;2：离散化&emsp;&emsp;知道了前置知识后，此题就比较简单了，首先因为此题的数据范围较大，如果我们直接按照坐标范围进行前缀和处理，则会出现 10000 * 10000 的矩阵，再进行枚举会超时。&emsp;&emsp;于是我们观察到，题目给了一个 N &lt;= 500 如果我们离散化 那么最多只有 1000 个点 大大减少了枚举的时间，因此我们离散化完再预处理二维的前缀和。&emsp;&emsp;最后我们开始枚举，若直接朴素枚举（每次枚举左上角起点再枚举正方形的边长）然后则会超时，因此我们考虑通过二分答案来枚举，就可以得到最后的答案了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAX = 10006, N = 506;int xx[MAX], yy[MAX];int c, n, tx = 0, ty = 0;int x[N], y[N], s[N][N];struct P &#123; int x, y;&#125; p[N];bool pd(int k) &#123; // 二分答案 判断答案是否合法 for (int i = xx[k]; i &lt;= tx; i++) for (int j = yy[k]; j &lt;= ty; j++) &#123; int x0 = 0, y0 = 0; if (x[i]-k &gt;= 0) x0 = xx[x[i]-k]; if (y[j]-k &gt;= 0) y0 = yy[y[j]-k]; if (s[i][j] - s[x0][j] - s[i][y0] + s[x0][y0] &gt;= c) return 1; &#125; return 0;&#125;int main() &#123; memset(xx, 0, sizeof(xx)); memset(yy, 0, sizeof(yy)); memset(s, 0, sizeof(s)); cin &gt;&gt; c &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; xx[p[i].x]++; yy[p[i].y]++; &#125; for (int i = 1; i &lt;= 10000; i++) &#123; // 离散化 if (xx[i]) x[++tx] = i; xx[i] = tx; if (yy[i]) y[++ty] = i; yy[i] = ty; &#125; for (int i = 1; i &lt;= n; i++) s[xx[p[i].x]][yy[p[i].y]]++; for (int i = 1; i &lt;= tx; i++) // 预处理二维前缀和 for(int j = 1; j &lt;= ty; j++) s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + s[i][j]; int l = 1, r = 10000; while (l &lt; r) &#123; // 二分答案 int mid = (l + r) &gt;&gt; 1; if (pd(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; return 0;&#125; D题：题解：&emsp;&emsp;题解内容较长：待补。12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 1e6 + 7;int n;ll a[N], k = 0;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;a[i]); k += a[i]; &#125; k /= n; a[0] = 0; for (int i = 1; i &lt;= n; i++) a[i] = a[i] - k + a[i-1]; sort(a + 1, a + n + 1); ll ans = 0; for (int i = 1; i &lt;= n / 2; i++) ans += a[n + 1 - i] - a[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; E题：题解：&emsp;&emsp;这题是前缀和 + 枚举 处理的方式比较特别。首先为了让最后的答案尽可能的大，我们删掉的数字肯定是从最小的开始删除。&emsp;&emsp;所以我们先将序列进行排序，然后（误区）开始考虑是删除还是加数字。但是实际上，我们可以直接通过枚举来直接得到最优解。（部分解释在代码） 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 7;ll arr[N], sum[N];ll ans;double ans_q;int main(void) &#123; int n, k, m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; arr[i]; sort (arr + 1, arr + 1 + n); for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + 1LL * arr[i]; // 认真考虑枚举的代码，因为要让最后的答案大 我们 考虑枚举删除多少个数字（从 0 -- min（m, n - 1)) // 因为最后必须要留下1个数字，所以是 n - 1 和 m 中取小的那个 不然平均数为0 // 每次删除掉个 i 个 数字 那么剩余的操作就是考虑 是否能加上剩余的操作， // 即 min(1LL * k * (n - i), 1LL * (m - i)); for (int i = 0; i &lt;= min(m, n - 1); i++) &#123; ans = sum[n] - sum[i] + min(1LL * k * (n - i), 1LL * (m - i)); ans_q = max(ans_q, 1.0 * ans / (n - i)); &#125; printf ("%f\n", ans_q);&#125; F题：题解：&emsp;&emsp;本题解法多种，我自己写的时候直接暴力处理出了前缀和，因为只含有 0 和 1 的串，所以处理出前缀和可以快速的知道某一段的区间内有多少个 0 和 1 （因为跟长度进行对比 若区间长度为 10 但是前缀和为 8 那么就有 8 个 1， 2 个 0）剩下的部分就是纯粹的模拟题目即可。 实际上由更好写方法，写麻烦了 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 7;long long arr[N];int main(void) &#123; string s1, s2; long long ans = 0; cin &gt;&gt; s1 &gt;&gt; s2; int len = s1.length(); for (int i = 0; i &lt; len; i++) arr[i + 1] = arr[i] + (s1[i] - '0'); for (int i = 0; i &lt; s2.length(); i++) &#123; if (i &lt; len) &#123; if (s2[i] == '0') ans += (s2.length() - len &gt;= i ? arr[i + 1] - arr[0] : arr[i + 1] - arr[i - (s2.length() - len)]); else ans += (s2.length() - len &gt;= i ? abs(arr[i + 1] - (i + 1)) : s2.length() - len + 1 - arr[i + 1] + arr[i - s2.length() + len]); &#125; else if (i &gt;= len &amp;&amp; i + len &lt; s2.length()) &#123; if (s2[i] == '0') ans += arr[len]; else ans += (len - arr[len]); &#125; else &#123; if (s2[i] == '0') ans += arr[len] - arr[i + len - s2.length()]; else ans += (s2.length() - i - arr[len] + arr[i + len - s2.length()]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; G题：题解：&emsp;&emsp;首先大家要自行了解一些前置知识：&emsp;&emsp;前置知识：&emsp;&emsp;&emsp;&emsp;1：快速幂&emsp;&emsp;&emsp;&emsp;2：乘法逆元&emsp;&emsp;（建议了解完了再看题解）之前单独写了一个题解：POJ 1845 H题：题解：&emsp;这题没有什么较难的地方，基本题目读懂了，知道前缀和的思想就能写出了。唯一稍微要注意一下精度上的问题。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define esp 1e-6using namespace std;int sum[5007];int main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, k; double maxn = -1; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; int q; cin &gt;&gt; q; sum[i] += sum[i - 1] + q; &#125; for (int i = k; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n - i; j++) &#123; double ans = (sum[j + i] - sum[j]) * 1.0 / i; maxn = max(ans, maxn); &#125; &#125; printf("%.8f", maxn); return 0;&#125; I题：&emsp;&emsp;本题与上一题难度差不多，查找答案的时候 二分 或者 直接朴素枚举 均可AC 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define esp 1e-6using namespace std;long long arr[200005];long long sum[200005];int main(void)&#123; long long n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;arr[i]); sum[i] = sum[i - 1] + arr[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; long long temp; scanf("%lld", &amp;temp); long long ans = lower_bound(sum + 1, sum + n + 1, temp) - sum; // STL 中自带的二分查找 cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; temp - sum[ans - 1]&lt;&lt; endl; &#125; return 0;&#125; J题：题解：&emsp;&emsp;训练赛原题，放出来只是为了方便大家补题。此题要点在于大家要了解一下位运算，顺便要区分一下逻辑运算和位运算的区别，了解后直接按照前缀和的思路求出对应的 &amp; | ^ O(1) 查询即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;using namespace std;const int N = 1e5 + 7;long long arr[N], preand[N], preor[N], sufand[N], sufor[N];int main()&#123; int n, q; while (~scanf("%d %d", &amp;n, &amp;q)) &#123; long long allxor = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;arr[i]); allxor ^= arr[i]; &#125; preand[1] = preor[1] = arr[1]; sufand[n] = sufor[n] = arr[n]; for (int i = 2; i &lt;= n; i++) &#123; preand[i] = arr[i] &amp; preand[i - 1]; preor[i] = arr[i] | preor[i - 1]; &#125; for (int i = n - 1; i &gt;= 1; i--) &#123; sufand[i] = arr[i] &amp; sufand[i + 1]; sufor[i] = arr[i] | sufor[i + 1]; &#125; while (q--) &#123; int p; scanf("%d", &amp;p); long long ansand, ansor, ansxor; if (p == 1) &#123; ansand = sufand[p + 1]; ansor = sufor[p + 1]; &#125; else if (p == n) &#123; ansand = preand[p - 1]; ansor = preor[p - 1]; &#125; else &#123; ansand = preand[p - 1] &amp; sufand[p + 1]; ansor = preor[p - 1] | sufor[p + 1]; &#125; ansxor = allxor ^ arr[p]; printf("%lld %lld %lld\n", ansand, ansor, ansxor); &#125; &#125; return 0;&#125; K题：题解：&emsp;&emsp;此题有一定的思考性，是一个简单的区间线段覆盖问题，此类问题考虑方式众多，难题解法一般以动态规划为主，但是此题仅仅是从 n 个线段中选取 n - 2 个线段，可以直接暴力枚举来解决，（先预处理出 n - 1 个线段区间覆盖，然后在枚举出另外一个线段，选出最优的情况） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;typedef long long ll;typedef long double ld;typedef unsigned long long ull;using namespace std;const int MX = 5007;int l[MX], r[MX];int a[MX];int md[MX];int f[MX];int main() &#123; ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= q; i++) &#123; cin &gt;&gt; l[i] &gt;&gt; r[i]; &#125; int ans = 0; for (int x = 1; x &lt;= q; x++) &#123; memset(a, 0, sizeof(a)); memset(md, 0, sizeof(md)); for (int i = 1; i &lt;= q; i++) &#123; // 先枚举出来 q - 1 个区间 if (i != x) &#123; md[l[i]]++; md[r[i] + 1]--; &#125; &#125; int sm = 0; int tot = 0; for (int i = 1; i &lt;= n; i++) &#123; // 枚举另外一个区间的情况 sm += md[i]; if (sm &gt; 0) &#123; tot++; &#125; f[i] = f[i - 1]; if (sm == 1) &#123; f[i]++; &#125; &#125; for (int y = 1; y &lt;= q; y++) &#123; if (x == y) &#123; continue; &#125; int cur = tot - (f[r[y]] - f[l[y] - 1]); ans = max(ans, cur); &#125; &#125; cout &lt;&lt; ans &lt;&lt; "\n"; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;538 (Div. 2)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-538-Div-2%2F</url>
    <content type="text"><![CDATA[Codeforces Round #538 (Div. 2) C C题： 题目链接: &emsp;&emsp;https://codeforces.com/contest/1114/problem/C题目大意: &emsp;&emsp;给定N, b,求 ${N!}$ 在 ${b}$ 进制下末尾有多少个0题目思路: &emsp;&emsp;本题思路从10进制类比入手会较好理解。 &emsp;&emsp;首先对于一个10进制数，末尾有多少个0，我们可以直接肉眼看出（废话），但是我们可以换个角度来理解这个结果。 &emsp;&emsp;由于${10=2*5}$所以实际上对于任意整数N(暂且不说 N!的情况)，我们可以认为N可以被若干个2和5所整除。 &emsp;&emsp;例如${N = 20, N = 2 * 2 * 5}$ 因为2出现了2次，5出现了1次，所以仅能组成1个10，那么我们可以得知末尾只能有一个0。 &emsp;&emsp;所以我们不难得出第一个结论：${N!}$在 ${b}$ 进制下末尾有多少个0，取决于${N!}$ 中存在多少个 ${b}$ 中出现最少次数的质因数， &emsp;&emsp;即: &emsp;&emsp;${b=\prod_{i=1}^m p_i^{c_i}}$ ${ans = min \{ p_i |min\{c_i | i \leq m \} , i \leq m\} }$,因此我们可以考虑打素数表，算出ans。 ​ &emsp;&emsp;第二个问题：如何计算${N !}$末尾有多少个0，我们已经算出来了ans(即最少出现次数的质因数，因此我们只要计算它的贡献为多少，就能解决这个问题。 &emsp;&emsp;举个例子：${50!}$ 在 ${10}$ 进制下，5在${5,10,15,20,25,30,35,40,45,50}$提供了一次贡献，但是因为${25,50}$本身拥有2个5，所以我们可以考虑倍增成25，再次计算贡献，即最后的出现次数应该为5与25的贡献之和。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1e6 + 7;long long prime[maxn];map&lt;long long, long long&gt; ind, cnt;long long getcnt(long long p, long long x) &#123; long long res = 0; while (x) &#123; res += x / p; x /= p; &#125; return res;&#125;int main() &#123; long long n, m; for (int i = 2; i &lt;= maxn; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= maxn / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125; cin &gt;&gt; n &gt;&gt; m; long long mm = m; for (long long i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; while (mm % prime[i] == 0) &#123; ind[prime[i]]++; mm /= prime[i]; &#125; &#125; if (mm != 1) &#123; ind[mm]++; &#125; for (long long i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; if (ind[prime[i]]) &#123; cnt[prime[i]] = getcnt(prime[i], n); &#125; &#125; if (mm != 1) &#123; cnt[mm] = getcnt(mm, n); &#125; long long ans = 1e18 + 1; for (auto i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; if (ind[prime[i]]) &#123; ans = min(ans, 1LL * cnt[prime[i]] / ind[prime[i]]); &#125; &#125; if (mm != 1) &#123; ans = min(ans, 1LL * cnt[mm] / ind[mm]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1845]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FPOJ1845%2F</url>
    <content type="text"><![CDATA[POJ1845 题目链接： &emsp;&emsp;https://vjudge.net/problem/POJ-1845 题目大意： &emsp;&emsp;给定 a, b 求 ${a^b}$ 的因数和 mod 9901 的结果 题目思路： &emsp;&emsp;了解几个数学知识。 &emsp;&emsp;整数唯一分解定理 : $ A = p_1^{k_1} * p_2^{k_2} * p_3^{k_3} \cdots p_i^{k_i}$ &emsp;($p_i$均为质数) &emsp;&emsp;对于A的所有约数之和 : &emsp;&emsp;$ S = (1 + p_1 + p_1^2 + p_1^3 + \cdots p_1^{k_1}) * (1 + p_2 + p_2^2 + p_2^3 + \cdots p_2^{k_2})\cdots(1 + p_i + p_i^2 + p_i^3 + \cdots p_i^{k_i})$ &emsp;&emsp;本题如果是用等比数列求和的公式来算最终的结果的话，需要进行逆元，而在逆元的过程中需要考虑 mod 9901 是否存在倍数的情况，所以需要进行特判。 &emsp;&emsp;由于POJ不支持bits/stdc++.h和auto，CE了好几次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int mod = 9901;const int Maxn = 2e5 + 7;int prime[Maxn];map&lt;int, int&gt; mp;long long pow_m (long long a, long long b, long long c) &#123; long long res = 1; a = a % c; while (b) &#123; if (b &amp; 1) res = (res * a) % c; a = (a * a) % c; b &gt;&gt;= 1; &#125; return res;&#125;long long inv (long long a) &#123; return pow_m(a, mod - 2, mod);&#125;void init() &#123; memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= Maxn; i++) &#123; if (!prime[i]) prime[++prime[0]] = i; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= Maxn / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main(void) &#123; long long ans = 1; long long a, b, n; init(); while (cin &gt;&gt; a &gt;&gt; b) &#123; ans = 1; if (a &lt;= 1 || b == 0) &#123; cout &lt;&lt; 1 &lt;&lt; endl; continue; &#125; mp.clear(); n = a; // cout &lt;&lt; 1 &lt;&lt; endl; for (int i = 1; prime[i] * prime[i] &lt;= n; i++) &#123; if (a == 1) break; if (a % prime[i] == 0) &#123; a /= prime[i]; mp[prime[i]]++; i--; &#125; &#125; if (a != 1) mp[a]++; // cout &lt;&lt; 1 &lt;&lt; endl; map&lt;int, int&gt; :: iterator it = mp.begin(); for (; it != mp.end(); it++) &#123; // cout &lt;&lt; i.first &lt;&lt;" " &lt;&lt; i.second &lt;&lt; endl; // cout &lt;&lt; (pow_m(i.first, b * i.second, mod) - 1) &lt;&lt; endl; if ((it -&gt; first - 1) % mod == 0) ans = (b * it-&gt;second + 1) % mod * ans % mod; else ans *= ((pow_m(it-&gt;first, b * it-&gt;second + 1, mod) + mod - 1) % mod * inv(it-&gt;first - 1)); ans %= mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;533 (Div. 2)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-533-Div-2%2F</url>
    <content type="text"><![CDATA[Codeforces Round #533 (Div. 2) C,D题 C题：正解是个dp，所以看代码吧。12345678910#include &lt;iostream&gt;using namespace std;int main(void)&#123; cout &lt;&lt; "发出了蒟蒻的声音.jpg" &lt;&lt; endl; cout &lt;&lt; "臣妾不会写啊.jpg" &lt;&lt; endl; cout &lt;&lt; "只好后面补了.jpg" &lt;&lt; endl; cout &lt;&lt; "咕咕咕咕.jpg" &lt;&lt; endl; return 0;&#125; D题 题目链接： &emsp;&emsp;http://codeforces.com/contest/1105/problem/D 题目大意： &emsp;&emsp;给一张N * M 的地图，每个人每轮有ai次扩展机会，‘.’为可扩展的地方，‘#’为墙，按序号(1 - n)依次扩展，扩展若干轮直到无法再扩展，问最后每个人扩展的数目为多少。 题目思路： &emsp;&emsp;其实这题就是简单的bfs跑一遍即可，用2个队列存储一下扩展点的顺序即可。（一个也行？大概吧。) 代码有点丑，将就着看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1007;struct node &#123; int x, y, val;&#125;;int n, m, p;int dir[4][2] = &#123;-1, 0, 1, 0, 0, -1, 0, 1&#125;;int arr[N], ans[15], vis[N][N];char srr[N][N];queue&lt;pair&lt;int, int&gt; &gt; que;queue&lt;node&gt; q;node fir[N];bool check (int x, int y) &#123; if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m || srr[x][y] == '#') return false; return true;&#125;int main(void)&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 1; i &lt;= p; i++) cin &gt;&gt; arr[i]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; srr[i][j]; memset(vis, -1, sizeof(vis)); for (int k = 1; k &lt;= p; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (srr[i][j] - '0' == k) &#123; vis[i][j] = k; que.push(make_pair(i, j)); &#125;// for (int i = 1; i &lt;= n; i++) &#123;// for (int j = 1; j &lt;= m; j++)// cout &lt;&lt; vis[i][j] &lt;&lt; " ";// cout &lt;&lt; endl;// &#125; while (!que.empty()) &#123; pair&lt;int, int&gt; pa = que.front(); que.pop(); int x = pa.first; int y = pa.second; q.push(&#123;x, y, arr[vis[x][y]]&#125;); while (!que.empty() &amp;&amp; vis[que.front().first][que.front().second] == vis[x][y]) &#123; q.push(&#123;que.front().first, que.front().second, arr[vis[x][y]]&#125;); que.pop(); &#125; while (!q.empty()) &#123; node tmp = q.front(); q.pop(); if (tmp.val &lt;= 0) continue; for (int i = 0; i &lt; 4; i++) &#123; int xx = tmp.x + dir[i][0]; int yy = tmp.y + dir[i][1]; if (check (xx, yy) &amp;&amp; vis[xx][yy] == -1) &#123; vis[xx][yy] = vis[x][y]; q.push(&#123;xx, yy, tmp.val - 1&#125;); que.push(make_pair(xx, yy)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (vis[i][j] != -1) ans[vis[i][j]]++; for (int i = 1; i &lt;= p; i++) cout &lt;&lt; ans[i] &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;531 (Div. 3)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-531-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #531 (Div. 3) D题 咕 咕咕 咕咕咕 123456789#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(void) &#123; cout &lt;&lt; "发出了鸽子的声音.jpg"; return 0;&#125; 后面补。 简单记录一下这个写得很丑陋的D题，顺便习惯下如何错误的写题解 题目链接： &emsp;&emsp;http://codeforces.com/contest/1102/problem/D 题目大意： &emsp;&emsp;给定一个长度为 n（保证 n 为 3 的倍数）的串，并且只含有0,1,2 3 种数字，让你替换某些数字，使得新得到的串的0,1,2的数量相同，要求替换次数最少，并在此要求下要求字典序最小。 题目思路： &emsp;&emsp;题目数据不算大，可以直接暴力模拟。之前比赛写的太丑陋了，看看正解怎么写的，学习下。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt[3], val[3];string s;int main(void) &#123; cin &gt;&gt; n &gt;&gt; s; m = n / 3; for (int i = 0; i &lt; n; i++) cnt[s[i] - '0']++; for (int i = 0; i &lt; 3; i++) val[i] = cnt[i]; for (int i = 0; i &lt; n; i++) &#123; val[s[i] - '0']--; if (cnt[s[i] - '0'] &gt; m) for (int j = 0; j &lt; 3; j++) if (cnt[j] &lt; m) &#123; if (j &gt; s[i] - '0' &amp;&amp; val[s[i] - '0'] &gt;= cnt[s[i] - '0'] - m) break; cnt[s[i] - '0']--; s[i] = char(j + '0'); cnt[j]++; break; &#125; &#125; cout &lt;&lt; s &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
