<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从零开始的前缀和]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C%2F</url>
    <content type="text"><![CDATA[从零开始的前缀和 只包含了题解和解题要点 不包含题意。（部分题单独写题解 附上链接） 题目链接：https://vjudge.net/contest/286126 &emsp;&emsp; 建议大家看完题解 及时补题。&emsp;&emsp; 建议大家看完题解 及时补题。&emsp;&emsp; 建议大家看完题解 及时补题。 A题：题解：&emsp;&emsp;此题为二维前缀和裸题，我们只需要将二维前缀和预处理出来，然后对于答案所求的边长进行枚举(从小到大)就可以得到一个最大的矩阵价值。&emsp;&emsp;然后我们需要注意枚举时的细节问题，为防止边长溢出（在-r时 具体见代码） 建议 i = r 开始枚举，无其他难点。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt; // 万能头文件（基本包括了能用到的所有函数） POJ不可以使用using namespace std;const int N = 5011;const int INF = 0x3f3f3f3f;int arr[N][N];int main(void)&#123; memset(arr, 0, sizeof(arr)); int n, r, maxc = -1, maxr = -1, ans = -1; cin &gt;&gt; n &gt;&gt; r; maxc = maxr = r; for (int i = 1; i &lt;= n; i++) &#123; int x, y, val; cin &gt;&gt; x &gt;&gt; y &gt;&gt; val; x++, y++; arr[x][y] = val; maxc = max(x, maxc); maxr = max(y, maxr); &#125; for (int i = 1; i &lt;= maxc; i++) &#123; // 二维前缀和预处理 for (int j = 1; j &lt;= maxr; j++) arr[i][j] += arr[i - 1][j] + arr[i][j - 1] - arr[i - 1][j - 1]; &#125; for (int i = r; i &lt;= maxc; i++) // 这里为了防止溢出 所以我从r开始枚举的。 for (int j = r; j &lt;= maxr; j++) &#123; ans = max(ans, arr[i][j] + arr[i - r][j - r] - arr[i - r][j] - arr[i][j - r]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B题：题解：&emsp;&emsp;此题为差分序列的裸题，将差分序列从区间问题转化成单点处理的问题，是差分序列的基本操作。&emsp;&emsp;然后我们需要注意此题的一个比较坑的点，由于在读入时有可能对同一区间操作若干次，但是实际上我们只要一次的单点处理，所以我们需要对处理过的区间标记一下。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int INF = 0x3f3f3f3f;int arr[10007];map&lt;pair&lt;int, int&gt;, int&gt;vis; //用map来对区间进行标记 pair大家可以成一个只包含了两个int类型的结构体。int main(void) &#123; int n, pos, h, R; while(cin &gt;&gt; n &gt;&gt; pos &gt;&gt; h &gt;&gt; R) &#123; vis.clear(); memset(arr, 0, sizeof(arr)); for (int i = 1; i &lt;= R; i++) &#123; int l, r; pair&lt;int, int&gt; pa; cin &gt;&gt; l &gt;&gt; r; if (l &gt; r) swap(l, r); pa.first = l, pa.second = r; if (vis[pa]) // 如果该区间已经出现过 则跳过。 continue; vis[pa]++; arr[l + 1]--; arr[r]++; &#125; for (int i = 1; i &lt;= n; i++) arr[i] += arr[i - 1]; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; arr[i] + h &lt;&lt; endl; &#125; return 0;&#125; C题：题解：&emsp;&emsp;此题有一些难度，大家需要掌握一些前置知识。&emsp;&emsp;前置知识：&emsp;&emsp;&emsp;&emsp;1：二分答案&emsp;&emsp;&emsp;&emsp;2：离散化&emsp;&emsp;知道了前置知识后，此题就比较简单了，首先因为此题的数据范围较大，如果我们直接按照坐标范围进行前缀和处理，则会出现 10000 * 10000 的矩阵，再进行枚举会超时。&emsp;&emsp;于是我们观察到，题目给了一个 N &lt;= 500 如果我们离散化 那么最多只有 1000 个点 大大减少了枚举的时间，因此我们离散化完再预处理二维的前缀和。&emsp;&emsp;最后我们开始枚举，若直接朴素枚举（每次枚举左上角起点再枚举正方形的边长）然后则会超时，因此我们考虑通过二分答案来枚举，就可以得到最后的答案了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAX = 10006, N = 506;int xx[MAX], yy[MAX];int c, n, tx = 0, ty = 0;int x[N], y[N], s[N][N];struct P &#123; int x, y;&#125; p[N];bool pd(int k) &#123; // 二分答案 判断答案是否合法 for (int i = xx[k]; i &lt;= tx; i++) for (int j = yy[k]; j &lt;= ty; j++) &#123; int x0 = 0, y0 = 0; if (x[i]-k &gt;= 0) x0 = xx[x[i]-k]; if (y[j]-k &gt;= 0) y0 = yy[y[j]-k]; if (s[i][j] - s[x0][j] - s[i][y0] + s[x0][y0] &gt;= c) return 1; &#125; return 0;&#125;int main() &#123; memset(xx, 0, sizeof(xx)); memset(yy, 0, sizeof(yy)); memset(s, 0, sizeof(s)); cin &gt;&gt; c &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; xx[p[i].x]++; yy[p[i].y]++; &#125; for (int i = 1; i &lt;= 10000; i++) &#123; // 离散化 if (xx[i]) x[++tx] = i; xx[i] = tx; if (yy[i]) y[++ty] = i; yy[i] = ty; &#125; for (int i = 1; i &lt;= n; i++) s[xx[p[i].x]][yy[p[i].y]]++; for (int i = 1; i &lt;= tx; i++) // 预处理二维前缀和 for(int j = 1; j &lt;= ty; j++) s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + s[i][j]; int l = 1, r = 10000; while (l &lt; r) &#123; // 二分答案 int mid = (l + r) &gt;&gt; 1; if (pd(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; endl; return 0;&#125; D题：题解：&emsp;&emsp;题解内容较长：待补。12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 1e6 + 7;int n;ll a[N], k = 0;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;a[i]); k += a[i]; &#125; k /= n; a[0] = 0; for (int i = 1; i &lt;= n; i++) a[i] = a[i] - k + a[i-1]; sort(a + 1, a + n + 1); ll ans = 0; for (int i = 1; i &lt;= n / 2; i++) ans += a[n + 1 - i] - a[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; E题：题解：&emsp;&emsp;这题是前缀和 + 枚举 处理的方式比较特别。首先为了让最后的答案尽可能的大，我们删掉的数字肯定是从最小的开始删除。&emsp;&emsp;所以我们先将序列进行排序，然后（误区）开始考虑是删除还是加数字。但是实际上，我们可以直接通过枚举来直接得到最优解。（部分解释在代码） 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 7;ll arr[N], sum[N];ll ans;double ans_q;int main(void) &#123; int n, k, m; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; arr[i]; sort (arr + 1, arr + 1 + n); for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + 1LL * arr[i]; // 认真考虑枚举的代码，因为要让最后的答案大 我们 考虑枚举删除多少个数字（从 0 -- min（m, n - 1)) // 因为最后必须要留下1个数字，所以是 n - 1 和 m 中取小的那个 不然平均数为0 // 每次删除掉个 i 个 数字 那么剩余的操作就是考虑 是否能加上剩余的操作， // 即 min(1LL * k * (n - i), 1LL * (m - i)); for (int i = 0; i &lt;= min(m, n - 1); i++) &#123; ans = sum[n] - sum[i] + min(1LL * k * (n - i), 1LL * (m - i)); ans_q = max(ans_q, 1.0 * ans / (n - i)); &#125; printf ("%f\n", ans_q);&#125; F题：题解：&emsp;&emsp;本题解法多种，我自己写的时候直接暴力处理出了前缀和，因为只含有 0 和 1 的串，所以处理出前缀和可以快速的知道某一段的区间内有多少个 0 和 1 （因为跟长度进行对比 若区间长度为 10 但是前缀和为 8 那么就有 8 个 1， 2 个 0）剩下的部分就是纯粹的模拟题目即可。 实际上由更好写方法，写麻烦了 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 7;long long arr[N];int main(void) &#123; string s1, s2; long long ans = 0; cin &gt;&gt; s1 &gt;&gt; s2; int len = s1.length(); for (int i = 0; i &lt; len; i++) arr[i + 1] = arr[i] + (s1[i] - '0'); for (int i = 0; i &lt; s2.length(); i++) &#123; if (i &lt; len) &#123; if (s2[i] == '0') ans += (s2.length() - len &gt;= i ? arr[i + 1] - arr[0] : arr[i + 1] - arr[i - (s2.length() - len)]); else ans += (s2.length() - len &gt;= i ? abs(arr[i + 1] - (i + 1)) : s2.length() - len + 1 - arr[i + 1] + arr[i - s2.length() + len]); &#125; else if (i &gt;= len &amp;&amp; i + len &lt; s2.length()) &#123; if (s2[i] == '0') ans += arr[len]; else ans += (len - arr[len]); &#125; else &#123; if (s2[i] == '0') ans += arr[len] - arr[i + len - s2.length()]; else ans += (s2.length() - i - arr[len] + arr[i + len - s2.length()]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; G题：题解：&emsp;&emsp;首先大家要自行了解一些前置知识：&emsp;&emsp;前置知识：&emsp;&emsp;&emsp;&emsp;1：快速幂&emsp;&emsp;&emsp;&emsp;2：乘法逆元&emsp;&emsp;（建议了解完了再看题解）之前单独写了一个题解：POJ 1845 H题：题解：&emsp;这题没有什么较难的地方，基本题目读懂了，知道前缀和的思想就能写出了。唯一稍微要注意一下精度上的问题。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define esp 1e-6using namespace std;int sum[5007];int main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, k; double maxn = -1; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; int q; cin &gt;&gt; q; sum[i] += sum[i - 1] + q; &#125; for (int i = k; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n - i; j++) &#123; double ans = (sum[j + i] - sum[j]) * 1.0 / i; maxn = max(ans, maxn); &#125; &#125; printf("%.8f", maxn); return 0;&#125; I题：&emsp;&emsp;本题与上一题难度差不多，查找答案的时候 二分 或者 直接朴素枚举 均可AC 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define esp 1e-6using namespace std;long long arr[200005];long long sum[200005];int main(void)&#123; long long n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;arr[i]); sum[i] = sum[i - 1] + arr[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; long long temp; scanf("%lld", &amp;temp); long long ans = lower_bound(sum + 1, sum + n + 1, temp) - sum; // STL 中自带的二分查找 cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; temp - sum[ans - 1]&lt;&lt; endl; &#125; return 0;&#125; J题：题解：&emsp;&emsp;训练赛原题，放出来只是为了方便大家补题。此题要点在于大家要了解一下位运算，顺便要区分一下逻辑运算和位运算的区别，了解后直接按照前缀和的思路求出对应的 &amp; | ^ O(1) 查询即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;using namespace std;const int N = 1e5 + 7;long long arr[N], preand[N], preor[N], sufand[N], sufor[N];int main()&#123; int n, q; while (~scanf("%d %d", &amp;n, &amp;q)) &#123; long long allxor = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;arr[i]); allxor ^= arr[i]; &#125; preand[1] = preor[1] = arr[1]; sufand[n] = sufor[n] = arr[n]; for (int i = 2; i &lt;= n; i++) &#123; preand[i] = arr[i] &amp; preand[i - 1]; preor[i] = arr[i] | preor[i - 1]; &#125; for (int i = n - 1; i &gt;= 1; i--) &#123; sufand[i] = arr[i] &amp; sufand[i + 1]; sufor[i] = arr[i] | sufor[i + 1]; &#125; while (q--) &#123; int p; scanf("%d", &amp;p); long long ansand, ansor, ansxor; if (p == 1) &#123; ansand = sufand[p + 1]; ansor = sufor[p + 1]; &#125; else if (p == n) &#123; ansand = preand[p - 1]; ansor = preor[p - 1]; &#125; else &#123; ansand = preand[p - 1] &amp; sufand[p + 1]; ansor = preor[p - 1] | sufor[p + 1]; &#125; ansxor = allxor ^ arr[p]; printf("%lld %lld %lld\n", ansand, ansor, ansxor); &#125; &#125; return 0;&#125; K题：题解：&emsp;&emsp;此题有一定的思考性，是一个简单的区间线段覆盖问题，此类问题考虑方式众多，难题解法一般以动态规划为主，但是此题仅仅是从 n 个线段中选取 n - 2 个线段，可以直接暴力枚举来解决，（先预处理出 n - 1 个线段区间覆盖，然后在枚举出另外一个线段，选出最优的情况） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;typedef long long ll;typedef long double ld;typedef unsigned long long ull;using namespace std;const int MX = 5007;int l[MX], r[MX];int a[MX];int md[MX];int f[MX];int main() &#123; ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= q; i++) &#123; cin &gt;&gt; l[i] &gt;&gt; r[i]; &#125; int ans = 0; for (int x = 1; x &lt;= q; x++) &#123; memset(a, 0, sizeof(a)); memset(md, 0, sizeof(md)); for (int i = 1; i &lt;= q; i++) &#123; // 先枚举出来 q - 1 个区间 if (i != x) &#123; md[l[i]]++; md[r[i] + 1]--; &#125; &#125; int sm = 0; int tot = 0; for (int i = 1; i &lt;= n; i++) &#123; // 枚举另外一个区间的情况 sm += md[i]; if (sm &gt; 0) &#123; tot++; &#125; f[i] = f[i - 1]; if (sm == 1) &#123; f[i]++; &#125; &#125; for (int y = 1; y &lt;= q; y++) &#123; if (x == y) &#123; continue; &#125; int cur = tot - (f[r[y]] - f[l[y] - 1]); ans = max(ans, cur); &#125; &#125; cout &lt;&lt; ans &lt;&lt; "\n"; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;538 (Div. 2)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-538-Div-2%2F</url>
    <content type="text"><![CDATA[Codeforces Round #538 (Div. 2) C C题： 题目链接: &emsp;&emsp;https://codeforces.com/contest/1114/problem/C题目大意: &emsp;&emsp;给定N, b,求 ${N!}$ 在 ${b}$ 进制下末尾有多少个0题目思路: &emsp;&emsp;本题思路从10进制类比入手会较好理解。 &emsp;&emsp;首先对于一个10进制数，末尾有多少个0，我们可以直接肉眼看出（废话），但是我们可以换个角度来理解这个结果。 &emsp;&emsp;由于${10=2*5}$所以实际上对于任意整数N(暂且不说 N!的情况)，我们可以认为N可以被若干个2和5所整除。 &emsp;&emsp;例如${N = 20, N = 2 * 2 * 5}$ 因为2出现了2次，5出现了1次，所以仅能组成1个10，那么我们可以得知末尾只能有一个0。 &emsp;&emsp;所以我们不难得出第一个结论：${N!}$在 ${b}$ 进制下末尾有多少个0，取决于${N!}$ 中存在多少个 ${b}$ 中出现最少次数的质因数， &emsp;&emsp;即: &emsp;&emsp;${b=\prod_{i=1}^m p_i^{c_i}}$ ${ans = min \{ p_i |min\{c_i | i \leq m \} , i \leq m\} }$,因此我们可以考虑打素数表，算出ans。 ​ &emsp;&emsp;第二个问题：如何计算${N !}$末尾有多少个0，我们已经算出来了ans(即最少出现次数的质因数，因此我们只要计算它的贡献为多少，就能解决这个问题。 &emsp;&emsp;举个例子：${50!}$ 在 ${10}$ 进制下，5在${5,10,15,20,25,30,35,40,45,50}$提供了一次贡献，但是因为${25,50}$本身拥有2个5，所以我们可以考虑倍增成25，再次计算贡献，即最后的出现次数应该为5与25的贡献之和。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 1e6 + 7;long long prime[maxn];map&lt;long long, long long&gt; ind, cnt;long long getcnt(long long p, long long x) &#123; long long res = 0; while (x) &#123; res += x / p; x /= p; &#125; return res;&#125;int main() &#123; long long n, m; for (int i = 2; i &lt;= maxn; i++) &#123; if (!prime[i]) &#123; prime[++prime[0]] = i; &#125; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= maxn / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125; cin &gt;&gt; n &gt;&gt; m; long long mm = m; for (long long i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; while (mm % prime[i] == 0) &#123; ind[prime[i]]++; mm /= prime[i]; &#125; &#125; if (mm != 1) &#123; ind[mm]++; &#125; for (long long i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; if (ind[prime[i]]) &#123; cnt[prime[i]] = getcnt(prime[i], n); &#125; &#125; if (mm != 1) &#123; cnt[mm] = getcnt(mm, n); &#125; long long ans = 1e18 + 1; for (auto i = 1; sqrt(m) &gt;= prime[i]; i++) &#123; if (ind[prime[i]]) &#123; ans = min(ans, 1LL * cnt[prime[i]] / ind[prime[i]]); &#125; &#125; if (mm != 1) &#123; ans = min(ans, 1LL * cnt[mm] / ind[mm]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1845]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FPOJ1845%2F</url>
    <content type="text"><![CDATA[POJ1845 题目链接： &emsp;&emsp;https://vjudge.net/problem/POJ-1845 题目大意： &emsp;&emsp;给定 a, b 求 ${a^b}$ 的因数和 mod 9901 的结果 题目思路： &emsp;&emsp;了解几个数学知识。 &emsp;&emsp;整数唯一分解定理 : $ A = p_1^{k_1} * p_2^{k_2} * p_3^{k_3} \cdots p_i^{k_i}$ &emsp;($p_i$均为质数) &emsp;&emsp;对于A的所有约数之和 : &emsp;&emsp;$ S = (1 + p_1 + p_1^2 + p_1^3 + \cdots p_1^{k_1}) * (1 + p_2 + p_2^2 + p_2^3 + \cdots p_2^{k_2})\cdots(1 + p_i + p_i^2 + p_i^3 + \cdots p_i^{k_i})$ &emsp;&emsp;本题如果是用等比数列求和的公式来算最终的结果的话，需要进行逆元，而在逆元的过程中需要考虑 mod 9901 是否存在倍数的情况，所以需要进行特判。 &emsp;&emsp;由于POJ不支持bits/stdc++.h和auto，CE了好几次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int mod = 9901;const int Maxn = 2e5 + 7;int prime[Maxn];map&lt;int, int&gt; mp;long long pow_m (long long a, long long b, long long c) &#123; long long res = 1; a = a % c; while (b) &#123; if (b &amp; 1) res = (res * a) % c; a = (a * a) % c; b &gt;&gt;= 1; &#125; return res;&#125;long long inv (long long a) &#123; return pow_m(a, mod - 2, mod);&#125;void init() &#123; memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= Maxn; i++) &#123; if (!prime[i]) prime[++prime[0]] = i; for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= Maxn / i; j++) &#123; prime[prime[j] * i] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main(void) &#123; long long ans = 1; long long a, b, n; init(); while (cin &gt;&gt; a &gt;&gt; b) &#123; ans = 1; if (a &lt;= 1 || b == 0) &#123; cout &lt;&lt; 1 &lt;&lt; endl; continue; &#125; mp.clear(); n = a; // cout &lt;&lt; 1 &lt;&lt; endl; for (int i = 1; prime[i] * prime[i] &lt;= n; i++) &#123; if (a == 1) break; if (a % prime[i] == 0) &#123; a /= prime[i]; mp[prime[i]]++; i--; &#125; &#125; if (a != 1) mp[a]++; // cout &lt;&lt; 1 &lt;&lt; endl; map&lt;int, int&gt; :: iterator it = mp.begin(); for (; it != mp.end(); it++) &#123; // cout &lt;&lt; i.first &lt;&lt;" " &lt;&lt; i.second &lt;&lt; endl; // cout &lt;&lt; (pow_m(i.first, b * i.second, mod) - 1) &lt;&lt; endl; if ((it -&gt; first - 1) % mod == 0) ans = (b * it-&gt;second + 1) % mod * ans % mod; else ans *= ((pow_m(it-&gt;first, b * it-&gt;second + 1, mod) + mod - 1) % mod * inv(it-&gt;first - 1)); ans %= mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;533 (Div. 2)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-533-Div-2%2F</url>
    <content type="text"><![CDATA[Codeforces Round #533 (Div. 2) C,D题 C题：正解是个dp，所以看代码吧。12345678910#include &lt;iostream&gt;using namespace std;int main(void)&#123; cout &lt;&lt; "发出了蒟蒻的声音.jpg" &lt;&lt; endl; cout &lt;&lt; "臣妾不会写啊.jpg" &lt;&lt; endl; cout &lt;&lt; "只好后面补了.jpg" &lt;&lt; endl; cout &lt;&lt; "咕咕咕咕.jpg" &lt;&lt; endl; return 0;&#125; D题 题目链接： &emsp;&emsp;http://codeforces.com/contest/1105/problem/D 题目大意： &emsp;&emsp;给一张N * M 的地图，每个人每轮有ai次扩展机会，‘.’为可扩展的地方，‘#’为墙，按序号(1 - n)依次扩展，扩展若干轮直到无法再扩展，问最后每个人扩展的数目为多少。 题目思路： &emsp;&emsp;其实这题就是简单的bfs跑一遍即可，用2个队列存储一下扩展点的顺序即可。（一个也行？大概吧。) 代码有点丑，将就着看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1007;struct node &#123; int x, y, val;&#125;;int n, m, p;int dir[4][2] = &#123;-1, 0, 1, 0, 0, -1, 0, 1&#125;;int arr[N], ans[15], vis[N][N];char srr[N][N];queue&lt;pair&lt;int, int&gt; &gt; que;queue&lt;node&gt; q;node fir[N];bool check (int x, int y) &#123; if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m || srr[x][y] == '#') return false; return true;&#125;int main(void)&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 1; i &lt;= p; i++) cin &gt;&gt; arr[i]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; srr[i][j]; memset(vis, -1, sizeof(vis)); for (int k = 1; k &lt;= p; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (srr[i][j] - '0' == k) &#123; vis[i][j] = k; que.push(make_pair(i, j)); &#125;// for (int i = 1; i &lt;= n; i++) &#123;// for (int j = 1; j &lt;= m; j++)// cout &lt;&lt; vis[i][j] &lt;&lt; " ";// cout &lt;&lt; endl;// &#125; while (!que.empty()) &#123; pair&lt;int, int&gt; pa = que.front(); que.pop(); int x = pa.first; int y = pa.second; q.push(&#123;x, y, arr[vis[x][y]]&#125;); while (!que.empty() &amp;&amp; vis[que.front().first][que.front().second] == vis[x][y]) &#123; q.push(&#123;que.front().first, que.front().second, arr[vis[x][y]]&#125;); que.pop(); &#125; while (!q.empty()) &#123; node tmp = q.front(); q.pop(); if (tmp.val &lt;= 0) continue; for (int i = 0; i &lt; 4; i++) &#123; int xx = tmp.x + dir[i][0]; int yy = tmp.y + dir[i][1]; if (check (xx, yy) &amp;&amp; vis[xx][yy] == -1) &#123; vis[xx][yy] = vis[x][y]; q.push(&#123;xx, yy, tmp.val - 1&#125;); que.push(make_pair(xx, yy)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (vis[i][j] != -1) ans[vis[i][j]]++; for (int i = 1; i &lt;= p; i++) cout &lt;&lt; ans[i] &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;531 (Div. 3)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-531-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #531 (Div. 3) D题 咕 咕咕 咕咕咕 123456789#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(void) &#123; cout &lt;&lt; "发出了鸽子的声音.jpg"; return 0;&#125; 后面补。 简单记录一下这个写得很丑陋的D题，顺便习惯下如何错误的写题解 题目链接： &emsp;&emsp;http://codeforces.com/contest/1102/problem/D 题目大意： &emsp;&emsp;给定一个长度为 n（保证 n 为 3 的倍数）的串，并且只含有0,1,2 3 种数字，让你替换某些数字，使得新得到的串的0,1,2的数量相同，要求替换次数最少，并在此要求下要求字典序最小。 题目思路： &emsp;&emsp;题目数据不算大，可以直接暴力模拟。之前比赛写的太丑陋了，看看正解怎么写的，学习下。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt[3], val[3];string s;int main(void) &#123; cin &gt;&gt; n &gt;&gt; s; m = n / 3; for (int i = 0; i &lt; n; i++) cnt[s[i] - '0']++; for (int i = 0; i &lt; 3; i++) val[i] = cnt[i]; for (int i = 0; i &lt; n; i++) &#123; val[s[i] - '0']--; if (cnt[s[i] - '0'] &gt; m) for (int j = 0; j &lt; 3; j++) if (cnt[j] &lt; m) &#123; if (j &gt; s[i] - '0' &amp;&amp; val[s[i] - '0'] &gt;= cnt[s[i] - '0'] - m) break; cnt[s[i] - '0']--; s[i] = char(j + '0'); cnt[j]++; break; &#125; &#125; cout &lt;&lt; s &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
