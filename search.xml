<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round &#35;533 (Div. 2)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-533-Div-2%2F</url>
    <content type="text"><![CDATA[Codeforces Round #533 (Div. 2) C,D题 C题：正解是个dp，所以看代码吧。12345678910#include &lt;iostream&gt;using namespace std;int main(void)&#123; cout &lt;&lt; "发出了蒟蒻的声音.jpg" &lt;&lt; endl; cout &lt;&lt; "臣妾不会写啊.jpg" &lt;&lt; endl; cout &lt;&lt; "只好后面补了.jpg" &lt;&lt; endl; cout &lt;&lt; "咕咕咕咕.jpg" &lt;&lt; endl; return 0;&#125; D题 题目链接： &emsp;&emsp;http://codeforces.com/contest/1105/problem/D 题目大意： &emsp;&emsp;给一张N * M 的地图，每个人每轮有ai次扩展机会，‘.’为可扩展的地方，‘#’为墙，按序号(1 - n)依次扩展，扩展若干轮直到无法再扩展，问最后每个人扩展的数目为多少。 题目思路： &emsp;&emsp;其实这题就是简单的bfs跑一遍即可，用2个队列存储一下扩展点的顺序即可。（一个也行？大概吧。) 代码有点丑，将就着看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1007;struct node &#123; int x, y, val;&#125;;int n, m, p;int dir[4][2] = &#123;-1, 0, 1, 0, 0, -1, 0, 1&#125;;int arr[N], ans[15], vis[N][N];char srr[N][N];queue&lt;pair&lt;int, int&gt; &gt; que;queue&lt;node&gt; q;node fir[N];bool check (int x, int y) &#123; if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m || srr[x][y] == '#') return false; return true;&#125;int main(void)&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 1; i &lt;= p; i++) cin &gt;&gt; arr[i]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; srr[i][j]; memset(vis, -1, sizeof(vis)); for (int k = 1; k &lt;= p; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (srr[i][j] - '0' == k) &#123; vis[i][j] = k; que.push(make_pair(i, j)); &#125;// for (int i = 1; i &lt;= n; i++) &#123;// for (int j = 1; j &lt;= m; j++)// cout &lt;&lt; vis[i][j] &lt;&lt; " ";// cout &lt;&lt; endl;// &#125; while (!que.empty()) &#123; pair&lt;int, int&gt; pa = que.front(); que.pop(); int x = pa.first; int y = pa.second; q.push(&#123;x, y, arr[vis[x][y]]&#125;); while (!que.empty() &amp;&amp; vis[que.front().first][que.front().second] == vis[x][y]) &#123; q.push(&#123;que.front().first, que.front().second, arr[vis[x][y]]&#125;); que.pop(); &#125; while (!q.empty()) &#123; node tmp = q.front(); q.pop(); if (tmp.val &lt;= 0) continue; for (int i = 0; i &lt; 4; i++) &#123; int xx = tmp.x + dir[i][0]; int yy = tmp.y + dir[i][1]; if (check (xx, yy) &amp;&amp; vis[xx][yy] == -1) &#123; vis[xx][yy] = vis[x][y]; q.push(&#123;xx, yy, tmp.val - 1&#125;); que.push(make_pair(xx, yy)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (vis[i][j] != -1) ans[vis[i][j]]++; for (int i = 1; i &lt;= p; i++) cout &lt;&lt; ans[i] &lt;&lt; " "; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round &#35;531 (Div. 3)]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FCodeforces-Round-531-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #531 (Div. 3) D题 咕 咕咕 咕咕咕 123456789#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(void) &#123; cout &lt;&lt; "发出了鸽子的声音.jpg"; return 0;&#125; 后面补。 简单记录一下这个写得很丑陋的D题，顺便习惯下如何错误的写题解 题目链接： &emsp;&emsp;http://codeforces.com/contest/1102/problem/D 题目大意： &emsp;&emsp;给定一个长度为 n（保证 n 为 3 的倍数）的串，并且只含有0,1,2 3 种数字，让你替换某些数字，使得新得到的串的0,1,2的数量相同，要求替换次数最少，并在此要求下要求字典序最小。 题目思路： &emsp;&emsp;题目数据不算大，可以直接暴力模拟。之前比赛写的太丑陋了，看看正解怎么写的，学习下。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt[3], val[3];string s;int main(void) &#123; cin &gt;&gt; n &gt;&gt; s; m = n / 3; for (int i = 0; i &lt; n; i++) cnt[s[i] - '0']++; for (int i = 0; i &lt; 3; i++) val[i] = cnt[i]; for (int i = 0; i &lt; n; i++) &#123; val[s[i] - '0']--; if (cnt[s[i] - '0'] &gt; m) for (int j = 0; j &lt; 3; j++) if (cnt[j] &lt; m) &#123; if (j &gt; s[i] - '0' &amp;&amp; val[s[i] - '0'] &gt;= cnt[s[i] - '0'] - m) break; cnt[s[i] - '0']--; s[i] = char(j + '0'); cnt[j]++; break; &#125; &#125; cout &lt;&lt; s &lt;&lt; '\n'; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
